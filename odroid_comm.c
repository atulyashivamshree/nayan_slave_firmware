/*
 * odroid_comm.c
 *
 *  Created on: 26-Apr-2015
 *      Author: nikhil
 */

#ifndef ODROID_COMM_C_
#define ODROID_COMM_C_

/**
 * @Warning DO NOT EDIT THIS FILE!
 * This file contain function related to intercommunication between Slave Processor and On-Board Computer
 */


#include "ch.h"
#include "hal.h"
#include "Setup.h"
#include "mavlink_types.h"
#include "OS_PORT/ext/mavlink/v1.0/common/mavlink.h"
#include "intercomm.h"
#include "main.h"

mavlink_system_t mavlink_system;

static mavlink_rc_channels_override_t rc_channels_override;

/**
 * variables defined by atulya
 */
static mavlink_vision_position_estimate_t vision_position_inp;

/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
static void send_heart_beat(void){

	mavlink_msg_heartbeat_send(MAVLINK_COMM_0,
			2,
			0,
		MAV_MODE_FLAG_CUSTOM_MODE_ENABLED,
		MAV_MODE_FLAG_STABILIZE_ENABLED,
		MAV_STATE_ACTIVE);
}

/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
static void send_scaled_imu(void){

	mavlink_msg_scaled_imu_send(MAVLINK_COMM_0,
			  millis(),
			  (int16_t)(sens_imu.accel_calib.x*1000),
			  (int16_t)(sens_imu.accel_calib.y*1000),
			  (int16_t)(sens_imu.accel_calib.z*1000),
			  (int16_t)(sens_imu.gyro_calib.x*1000),
			  (int16_t)(sens_imu.gyro_calib.y*1000),
			  (int16_t)(sens_imu.gyro_calib.z*1000),
			  (int16_t)(rc_channels_override.chan1_raw),
			  (int16_t)(rc_channels_override.chan2_raw),
			  (int16_t)1000);
}

/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
static void send_attitude(void){

	mavlink_msg_attitude_send(
			MAVLINK_COMM_0,
			millis(),
			ahrs.attitude.x,
			ahrs.attitude.y,
			ahrs.attitude.z,
			sens_imu.gyro_calib.x,
			sens_imu.gyro_calib.y,
			sens_imu.gyro_calib.z);
}

/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
static void send_gps(void){

	mavlink_msg_global_position_int_send(
			MAVLINK_COMM_0,
			millis(),
			sens_gps.lat,
			sens_gps.lng,
			sens_gps.alt,
			sens_gps.alt,
			velocity.x,
			velocity.y,
			velocity.z,
			(int16_t)(ahrs.attitude.z*5729.57));
}

/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
static void send_rc_in(void){
    mavlink_msg_rc_channels_raw_send(
    	MAVLINK_COMM_0,
        millis(),
        0, // port
        rc_in[0],
		rc_in[1],
		rc_in[2],
		rc_in[3],
		rc_in[4],
		rc_in[5],
		rc_in[6],
		0,
        -1);
}
/**
 * changes made by atulya
 */
static void send_local_position_ned(void)
{
	mavlink_msg_local_position_ned_send(
			MAVLINK_COMM_0,
			millis(),
			vis_pos.x,
			vis_pos.y,
			vis_pos.z,
			vis_vel.x,
			vis_vel.y,
			vis_vel.z);
}

/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */

static WORKING_AREA(mavlinkSendThread, 8192);
static msg_t mavlinkSend(void *arg) {

  (void)arg;
  chRegSetThreadName("mavlinkSend");

  uint16_t hbt_cnt = 0;

  uint16_t gps_cnt = 0;

  uint16_t rc_cnt = 0;

  uint16_t vis_cnt = 0;

  while (TRUE) {

	  if(hbt_cnt > 200){
		  send_heart_beat();
		  hbt_cnt = 0;
	  }

	  send_scaled_imu();

	  send_attitude();

	  if(vis_cnt > 3)
	  {
		  send_local_position_ned();
		  vis_cnt = 0;
	  }

	  if(gps_cnt > 40){
		  send_gps();
		  gps_cnt = 0;
	  }

	  if(rc_cnt > 4){
		  send_rc_in();
		  rc_cnt = 0;
	  }

	  chThdSleep(US2ST(4500));
	  hbt_cnt++;
	  gps_cnt++;
	  rc_cnt++;
	  vis_cnt++;

  }
  return 0;
}

/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
uint16_t comm_get_available(mavlink_channel_t chan){
	int16_t bytes = 0;
	   switch(chan) {
		case MAVLINK_COMM_0:
			bytes = chQSpaceI(&(&SDU1)->iqueue);
			break;
		default:
			break;
	   }
	   return bytes;
}

/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
uint8_t comm_receive_ch(mavlink_channel_t chan)
{
    uint8_t data = 0;
    switch(chan) {
	case MAVLINK_COMM_0:
		data = sdGetTimeout(&SDU1, 2);
		break;

	default:
		break;
	}
    return data;
}

/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
void send_params(void){
	mavlink_msg_param_value_send(
					 MAVLINK_COMM_0,
					 "SYSID_THISMAV",
					 1,
					 MAVLINK_TYPE_UINT8_T,
					 0,
					 3);

	mavlink_msg_param_value_send(
					 MAVLINK_COMM_0,
					 "SYSID_SW_TYPE",
					 10,
					 MAVLINK_TYPE_UINT8_T,
					 1,
					 3);

	mavlink_msg_param_value_send(
					 MAVLINK_COMM_0,
					 "SYSID_MYGCS",
					 255,
					 MAVLINK_TYPE_UINT8_T,
					 2,
					 3);
}

/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
void handleMessage(mavlink_message_t* msg)
{

    switch (msg->msgid) {

    case MAVLINK_MSG_ID_HEARTBEAT:
    {

        break;
    }

    case MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE:
     {

    	 palTogglePad(GPIOC, 1);
    	 mavlink_msg_rc_channels_override_decode(msg, &rc_channels_override);

		ic_rc_or_data.ic_rc.rc1 = rc_channels_override.chan1_raw;
		ic_rc_or_data.ic_rc.rc2 = rc_channels_override.chan2_raw;
		ic_rc_or_data.ic_rc.rc3 = rc_channels_override.chan3_raw;
		ic_rc_or_data.ic_rc.rc4 = rc_channels_override.chan4_raw;
		ic_rc_or_data.ic_rc.rc5 = rc_channels_override.chan5_raw;
		ic_rc_or_data.ic_rc.rc6 = rc_channels_override.chan6_raw;
		ic_rc_or_data.ic_rc.rc7 = rc_channels_override.chan7_raw;

         break;
     }

    case MAVLINK_MSG_ID_PARAM_REQUEST_LIST:
    {
    	send_params();

    	break;
    }

    case MAVLINK_MSG_ID_MISSION_REQUEST_LIST:
    {
    	mavlink_msg_mission_count_send(MAVLINK_COMM_0, 1, 0, 0);
    	break;
    }

    /**
     * additions by atulya
     */

    case MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE:
    {
    	mavlink_msg_vision_position_estimate_decode(msg, &vision_position_inp);
    	vis_pos_inp.x = vision_position_inp.x;
    	vis_pos_inp.y = vision_position_inp.y;
    	vis_pos_inp.z = vision_position_inp.z;
    	vis_inp_time = vision_position_inp.usec;

    	break;
    }

    default:
    	break;

    }
}


/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */

void odroid_update(void )
{

    mavlink_message_t msg;
    mavlink_status_t status;
    status.packet_rx_drop_count = 0;


    uint16_t nbytes = comm_get_available(MAVLINK_COMM_0);

    uint16_t i = 0;

    for (i = 0; i<nbytes; i++)
    {
        uint8_t c = comm_receive_ch(MAVLINK_COMM_0);

        if (mavlink_parse_char(MAVLINK_COMM_0, c, &msg, &status)) {

            handleMessage(&msg);
        }
    }
}

/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
static WORKING_AREA(mavlinkReceiveThread, 8192);
static msg_t mavlinkReceive(void *arg) {

  (void)arg;
  chRegSetThreadName("mavlinkReceive");

  while (TRUE) {
	  odroid_update();
	  delay(10);
  }
  return 0;
}
/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */

void odroid_comm_init(void){

	mavlink_system.sysid = 1;

	mavlink_system.type = 2;

	chThdCreateStatic(mavlinkReceiveThread, sizeof(mavlinkReceiveThread), NORMALPRIO, mavlinkReceive, NULL);
	chThdCreateStatic(mavlinkSendThread, sizeof(mavlinkSendThread), NORMALPRIO, mavlinkSend, NULL);

}

#endif /* ODROID_COMM_C_ */
